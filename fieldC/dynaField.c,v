head	1.10;
access;
symbols;
locks
	ndd:1.10; strict;
comment	@ * @;


1.10
date	2018.04.05.17.48.00;	author ndd;	state Exp;
branches;
next	1.9;

1.9
date	2018.04.05.13.10.10;	author ndd;	state Exp;
branches;
next	1.8;

1.8
date	2018.04.04.17.18.53;	author ndd;	state Exp;
branches;
next	1.7;

1.7
date	2018.04.03.17.15.19;	author ndd;	state Exp;
branches;
next	1.6;

1.6
date	2018.03.30.16.59.36;	author ndd;	state Exp;
branches;
next	1.5;

1.5
date	2018.03.26.14.33.32;	author ndd;	state Exp;
branches;
next	1.4;

1.4
date	2018.03.21.18.05.42;	author ndd;	state Exp;
branches;
next	1.3;

1.3
date	2018.03.19.17.57.49;	author ndd;	state Exp;
branches;
next	1.2;

1.2
date	2018.03.16.15.36.04;	author ndd;	state Exp;
branches;
next	1.1;

1.1
date	2018.03.16.15.16.08;	author ndd;	state Exp;
branches;
next	;


desc
@C version of dynaField.m
@


1.10
log
@did some cleanup on the debugging, made some more progress on xdc_get.
working on excitation now.
@
text
@/*
% function [intensity, FIELD_PARAMS]=dynaField(FIELD_PARAMS, threads, lownslow)
*
* no need for lownslow because C can't compute the whole array at once
*
%
% Generate intensity values at the nodal locations for conversion to force and
% input into the dyna deck.
%
% INPUTS:
%   FIELD_PARAMS.alpha (float) - absorption (dB/cm/MHz)
%   FIELD_PARAMS.measurementPointsandNodes - nodal IDs and spatial locations
%                                            from field2dyna.m
%   FIELD_PARAMS.Fnum (float) - F/#
%   FIELD_PARAMS.focus - [x y z] (m)
%   FIELD_PARAMS.Frequency (float) - push frequency (MHz)
%                                    6.67 (VF10-5)
%                                    4.21 (VF7-3)
%   FIELD_PARAMS.Transducer (string) - 'vf105'; select the
%       transducer-dependent parameters to use for the simulation
%   FIELD_PARAMS.Impulse (string) - 'gaussian','exp'; use a Gaussian function
%       based on the defined fractional bandwidth and center
%       frequency, or use the experimentally-measured impulse
%       response
%   threads (int) - number of parallel threads to use [default = numCores]
%   lownslow (bool) - low RAM footprint, but much slower
%   numNodes - number of nodes from readMpn
%
% OUTPUT:
%   intensity - intensity values at all of the node locations
%   FIELD_PARAMS - field parameter structure
%
% EXAMPLE:
%   [intensity, FIELD_PARAMS] = dynaField(FIELD_PARAMS)
%
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "field.h"		/* includes field_II.h */
#include "cJSON.h"

#define RECT 1	/* type of info we want from xdc_get */
#define ROWS 26	/* amount of information xdc_get returns for each rectangle */

dynaField(struct FieldParams params, int threads, int numNodes)
{
int i, j;
int debug = 0;
sys_con_type   *sys_con;      /*  System constants for Field II */ 
aperture_type *Th;
int info;
cJSON *commands, *impulseResponseCmd, *probeInfo;
cJSON *item;
FILE *input;
long len;
char *data, *out;
int no_elements, no_sub_x, no_sub_y;
int no_elements_y;
double width, height, kerf, Rconvex, Rfocus;
double heights;
double convexRadius, elvFocus, pitch, fractBandwidth, centerFreq;
point_type *focus;
double exciteFreq, texcite;
signal_type *excitationPulse;
signal_type **pressure;
double stepSize;
double freqAtt, attF0, att;
int numCYC = 50;
int numSteps;
double *intensity;
point_type *points;
char *thCmd, *impulseCmd;
double *impulseResponse;
double f0, phase, bw;
char *wavetype;

/* how do I do check_add_probes? */

/*
 * initialize Field II; field_init is in the provided c library; the '-1'
 * arg supresses ascii output.
 */
	
	sys_con = field_init(-1);

/* set transducer-independent parameters */

	if (debug) fprintf(stderr, "sampling frequency %d\n", params.samplingFrequency);

	set_field("c", params.soundSpeed);
	set_field("fs", params.samplingFrequency);
	set_field("threads", params.threads);
	if (debug) fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n", threads, params.threads);

/* get info from JSON */
	input = fopen("./c52Fixed.json","rb");
	fseek(input,0,SEEK_END);
	len=ftell(input );
	fseek(input,0,SEEK_SET);
	data=(char*)malloc(len+1);
	fread(data,1,len,input);
	fclose(input);

	probeInfo = cJSON_Parse(data);
	if (!probeInfo) {
		printf("Error before: [%s]\n",cJSON_GetErrorPtr());
		}

	else {
		out=cJSON_Print(probeInfo);
/* 		printf("%s\n",out); */
		free(out);
		}

	if (debug) fprintf(stderr, "array size %d\n", cJSON_GetArraySize(probeInfo));

	no_elements = cJSON_GetObjectItem(probeInfo, "no_elements")->valueint;
	no_sub_x = cJSON_GetObjectItem(probeInfo, "no_sub_x")->valueint;
	no_sub_y = cJSON_GetObjectItem(probeInfo, "no_sub_y")->valueint;

	if (debug) fprintf(stderr, "elements %d subX %d subY %d\n", no_elements, no_sub_x,
		no_sub_y);

	width = cJSON_GetObjectItem(probeInfo, "width")->valuedouble;
	if (debug) fprintf(stderr, "width %f\n", width);
	height = cJSON_GetObjectItem(probeInfo, "height")->valuedouble;
	kerf = cJSON_GetObjectItem(probeInfo, "kerf")->valuedouble;
	Rconvex = cJSON_GetObjectItem(probeInfo, "Rconvex")->valuedouble;
	Rfocus = cJSON_GetObjectItem(probeInfo, "Rfocus")->valuedouble;
	convexRadius = cJSON_GetObjectItem(probeInfo, "convex_radius")->valuedouble;
	elvFocus = cJSON_GetObjectItem(probeInfo, "elv_focus")->valuedouble;
	pitch = cJSON_GetObjectItem(probeInfo, "pitch")->valuedouble;
	fractBandwidth = cJSON_GetObjectItem(probeInfo, "fractionalBandwidth")->valuedouble;
	centerFreq = cJSON_GetObjectItem(probeInfo, "centerFrequency")->valuedouble;

/*
*/
	if (debug) fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probe_type")->valuestring);
	commands = cJSON_GetObjectItem(probeInfo, "commands");
	thCmd = cJSON_GetObjectItem(commands, "Th")->valuestring;
	if (debug) fprintf(stderr, "Th command %s\n", thCmd);

/* set aperture. as of now, there are only 3 xdc calls for this */

	if (strstr(thCmd, "xdc_concave") != NULL) {
/* optical piston only? should this be handled differently? */
		fprintf(stderr, "calling xdc_concave\n");
		Th = xdc_concave(9.5E-3, 38E-3, 0.5E-3);
		}

	if (strstr(thCmd, "xdc_convex_focused_array") != NULL) {
		fprintf(stderr, "calling xdc_convex_focused_array\n");
		Th = xdc_convex_focused_array(no_elements,width,height,kerf,Rconvex,
			Rfocus,no_sub_x,no_sub_y,params.focus);
		if (debug) fprintf(stderr, "from xdc_focused_multirow got info: %s %s\n",
			Th->information.name, Th->information.create_date);
		}

	else if (strstr(thCmd, "xdc_focused_multirow") != NULL) {
/* linear only? should this be handled differently? */
		fprintf(stderr, "calling xdc_focused_multirow\n");
		no_elements_y = 1;
		heights = height;
		Th = xdc_focused_multirow(no_elements,width,no_elements_y,&heights,
			kerf,kerf, Rfocus,no_sub_x,no_sub_y,params.focus);
		}

	else fprintf(stderr, "unknown aperture command\n");

	if (debug) fprintf(stderr, "impulse response command %s\n", cJSON_GetObjectItem(commands, "impulseResponse")->valuestring);
	impulseResponseCmd = cJSON_GetObjectItem(probeInfo, "impulse_response");

	f0 = cJSON_GetObjectItem(impulseResponseCmd, "f0")->valueint;
	phase = cJSON_GetObjectItem(impulseResponseCmd, "phase")->valueint;
	bw = cJSON_GetObjectItem(impulseResponseCmd, "bw")->valueint;
	wavetype = cJSON_GetObjectItem(impulseResponseCmd, "wavetype")->valuestring;
	
	if (debug) fprintf(stderr, "f0 %f phase %f bw %f\n", f0, phase, bw);
	if (debug) fprintf(stderr, "wavetype %s\n", wavetype);

/*
 * I think the next thing is to set impulse. this seems to be the same for
 * all the apertures. the matlab code calls defineImpulseResponse() which
 * calls * the matlab routine 'gauspuls', but since I had to write my own
 * I'm going to skip defineImpulseResponse()
 */

	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params, debug);

	if (debug) fprintf(stderr, "impulse response %f %f %f\n", impulseResponse[0],
		impulseResponse[1], impulseResponse[2]);
	if (debug) fprintf(stderr, "num apertures from sys_con %d\n", sys_con->No_apertures);

	info = RECT;

	params.ThData = (double *)malloc(ROWS * no_elements * no_sub_y * sizeof(double));
	
	xdc_get(Th, info, params.ThData);

	fprintf(stderr, "num apertures from sys_con %d\n", sys_con->No_apertures);
	fprintf(stderr, "rect? %d\n", sys_con->Use_rectangles);
	fprintf(stderr, "tri? %d\n", sys_con->Use_triangles);

/*
	for (i = 0; i < 20; i++)
	fprintf(stderr, "back from xdc_get, got %f\n", params.ThData[i]);
	fprintf(stderr, "done from xdc_get\n");
*/

/*
% figure out the axial shift (m) that will need to be applied to the scatterers
% to accomodate the mathematical element shift due to the lens
*/
	
	exciteFreq = params.frequency * 1000000;
	stepSize = 1.0 / params.samplingFrequency;

	fprintf(stderr, "params.frequency %f exciteFreq %f stepSize %g\n", params.frequency, exciteFreq, stepSize);
	numSteps = (int) (numCYC / exciteFreq / stepSize);

	excitationPulse = (signal_type *)malloc(sizeof(signal_type));
	excitationPulse->data = (double *)malloc(numSteps * sizeof(double));
	fprintf(stderr, "setting excitationPulse; numSteps %d\n", numSteps);

	excitationPulse->data[0] = 0;

	for (i = 1; i < numSteps; i++) {
		excitationPulse->data[i] = sin(2 * M_PI * exciteFreq * i * stepSize);
		}

	fprintf(stderr, "calling excitation\n");
	for (i = 0; i < 30; i++)
		fprintf(stderr, "got %f\n", Th->excitation[i]);
	xdc_excitation(Th, excitationPulse);
	fprintf(stderr, "back from excitation\n");
	for (i = 0; i < 30; i++)
		fprintf(stderr, "got %f\n", Th->excitation[i]);

	freqAtt = params.alpha * 100 / 1E6; /* frequency atten. in dB/cm/MHz */

	attF0 = exciteFreq;
	att = freqAtt * attF0; /* set non freq. dep. to be centered here */
	set_field("att", att);
	set_field("Freq_att", freqAtt);
	set_field("att_f0", attF0);
	set_field("use_att", 1);

/*
% compute Ispta at each location for a single tx pulse
% optimizing by computing only relevant nodes... will assume others are zero
*
* how many points does calc_hp return?
*
*/
	intensity = (double *)malloc(sizeof(double));

	for (i = 0; i < numNodes; i++) {
		points->x = params.pointsAndNodes[i].x;
		points->y = params.pointsAndNodes[i].y;
		points->z = params.pointsAndNodes[i].z;

		pressure = calc_hp(Th, 1, points);
/* 		for (j = 0; j < ?; j++) intensity[i] +=  *(pressure[j]->data) * *(pressure[j]->data; */
		}
			

}
@


1.9
log
@made some fixed for impulse response, read some more constants from JSON
file
@
text
@d44 3
d50 1
d53 1
a53 1
char *info;
a63 1
double *foo;
a78 5
/*
for (i = 0; i < 13; i++)
        fprintf(stderr, "in dynaField, node %d is %d, %f, %f, %f\n", i, params.pointsAndNodes[i].nodeID, params.pointsAndNodes[i].x, params.pointsAndNodes[i].y, params.pointsAndNodes[i].z);

*/
d90 1
a90 1
	fprintf(stderr, "sampling frequency %d\n", params.samplingFrequency);
d95 1
a95 1
	fprintf(stderr, "PARALLEL THREADS: %d param threads %d\n", threads, params.threads);
d117 1
a117 1
	fprintf(stderr, "array size %d\n", cJSON_GetArraySize(probeInfo));
d123 1
a123 1
	fprintf(stderr, "elements %d subX %d subY %d\n", no_elements, no_sub_x,
d127 1
a127 1
	fprintf(stderr, "width %f\n", width);
d140 1
a140 1
	fprintf(stderr, "type %s\n", cJSON_GetObjectItem(probeInfo, "probe_type")->valuestring);
d143 1
a143 1
	fprintf(stderr, "Th command %s\n", thCmd);
d157 1
a157 1
		fprintf(stderr, "from xdc_focused_multirow got info: %s %s\n",
d172 1
a172 1
	fprintf(stderr, "impulse response command %s\n", cJSON_GetObjectItem(commands, "impulseResponse")->valuestring);
d180 2
a181 2
	fprintf(stderr, "f0 %f phase %f bw %f\n", f0, phase, bw);
	fprintf(stderr, "wavetype %s\n", wavetype);
d190 1
a190 1
	impulseResponse = gaussPulse(fractBandwidth, centerFreq, params);
d192 1
a192 1
	fprintf(stderr, "impulse response %f %f %f\n", impulseResponse[0],
d194 1
a194 1
	fprintf(stderr, "num apertures from sys_con %d\n", sys_con->No_apertures);
d196 1
a196 2
	info = "rect";
	fprintf(stderr, "info is %s\n", info);
d198 1
a198 1
/* 	foo = (double *)malloc(26*no_elements*no_sub_y*sizeof(double)); */
d200 1
a200 1
	xdc_get(Th, info, foo);
d206 1
a206 2
	fprintf(stderr, "back from xdc_get, got %f\n", foo[0]);

d208 1
a208 1
	fprintf(stderr, "back from xdc_get, got %f\n", foo[i]);
a209 1
/*
d234 2
d238 2
@


1.8
log
@some more progress on reading the JSON file, added impulse response
@
text
@d50 1
a50 1
cJSON *commands, *impulseResponse, *probeInfo;
d72 3
d92 2
d151 1
d156 1
d159 2
d165 1
d175 9
a183 4
	impulseResponse = cJSON_GetObjectItem(probeInfo, "impulse_response");
	fprintf(stderr, "center freq %d\n", cJSON_GetObjectItem(impulseResponse, "f0")->valueint);
	fprintf(stderr, "phase %d\n", cJSON_GetObjectItem(impulseResponse, "phase")->valueint);
	fprintf(stderr, "bw %d\n", cJSON_GetObjectItem(impulseResponse, "bw")->valueint);
d194 2
a195 1
	fprintf(stderr, "#elements %d\n", Th->no_elements);
d199 1
d204 1
d208 3
a210 2
/*
*/
d214 2
@


1.7
log
@made some more progress on handling the aperture commands
@
text
@d21 1
a21 1
%   FIELD_PARAMS.Impulse (string) - 'guassian','exp'; use a Gaussian function
d56 1
d58 2
d129 5
d157 2
a158 1
		Th = xdc_focused_multirow(no_elements,width,no_elements_y,height,
d172 3
a174 1
 * all the apertures
d176 2
@


1.6
log
@some code corrections
@
text
@d68 1
d128 1
d131 24
a154 1
	fprintf(stderr, "Th %s\n", cJSON_GetObjectItem(commands, "Th")->valuestring);
a159 1
*/
d161 4
a164 3
/* I think the next thing is to set Th, impulse */

	Th = xdc_convex_focused_array(no_elements,width,height,kerf,Rconvex,Rfocus,no_sub_x,no_sub_y,params.focus);
@


1.5
log
@getting closer to having all the code
@
text
@d3 3
d44 1
a44 1
dynaField(struct FieldParams params, int threads, int lowNslow, int numNodes)
d46 1
a46 1
int i;
d61 1
d66 2
d72 1
a73 1

d88 1
a88 1
	fprintf(stderr, "PARALLEL THREADS: %d\n", threads);
d146 1
a146 1
	foo = (double *)malloc(26*1344*sizeof(double));
d152 3
a154 1
	for (i = 0; i < 40; i++)
d156 1
d163 2
a164 2
	exciteFreq = params.frequency * 1E6;
	stepSize = 1 / exciteFreq;
d166 2
a167 1
	numSteps = (int) (numCYC * exciteFreq) * 2;
d169 1
d171 1
d175 1
a175 1
	for (i = 0; i < numSteps; i++) {
d179 1
d181 1
d195 10
d206 3
a208 4
	if (lowNslow) {
		fprintf(stderr, "running low-n-slow\n");
		for (i = 0; i < numNodes; i++) {
*/
@


1.4
log
@added some more code
@
text
@d24 1
d41 1
a41 1
dynaField(struct FieldParams params, int threads, int lowNslow)
d56 3
a58 1
double exciteFreq, texcite, *excitationPulse, stepSize;
d159 1
a159 1
	excitationPulse = (double *)malloc(numSteps * sizeof(double));
d161 1
a161 1
	excitationPulse[0] = 0;
d164 1
a164 1
		excitationPulse[i] = sin(2 * M_PI * exciteFreq * i * stepSize);
d173 15
a187 4
	set_field('att', att);
	set_field('Freq_att', freqAtt);
	set_field('att_f0', attF0);
	set_field('use_att', 1);
@


1.3
log
@I think that xdc_convex_focused_array is working, but xdc_get isn't
@
text
@d36 1
a36 1
#include <pthread.h>	/* needed to keep types.h (from field_II.h) happy */
d55 9
d97 1
a97 1
		printf("%s\n",out);
d133 1
d140 34
a173 1
	fprintf(stderr, "back from xdc_get, got %f %f %f\n", foo[4], foo[5], foo[6]);
@


1.2
log
@first cut at parsing JSON
@
text
@d35 1
d42 1
d46 2
a47 1
cJSON *probeInfo;
d51 4
a87 1
		cJSON_Delete(probeInfo);
d92 27
d121 4
d126 5
a130 1
	xdc_get(Th, info, params.ThData);
@


1.1
log
@Initial revision
@
text
@d37 1
d44 4
d64 21
@
